import DMX = require('dmx');
import * as core from './core-exec';
import * as console from './console';
import { _await } from './core-exec';

export let allFixtures  : Array<Fixture> = [];
export let universeName : string = 'pidmx';
export let dmxController : DMX | undefined;

core.onInit(() => {
    console.info("initializing shit");
    
    dmxController = new DMX();

    if (dmxController) {
        // TO DO: make the set up of the DMX USB more dynamic so different ports & devices can be used
        //universe = dmxController.addUniverse(universeName, 'dmxking-ultra-dmx-pro', '/dev/ttyUSB0');
        dmxController.addUniverse(universeName, 'dmxking-ultra-dmx-pro', '/dev/ttyUSB0');
        //const universe = dmx.addUniverse(universeName, 'null');
        console.info("initialized dmx universe");
    } else {
        console.info("unable to initialize dmx universe");
    }
    return;
});

export enum RGBFixtureType {
    Baisun8ch,
    Coidak8ch
}

export enum Colors {
    Red = 0xFF0000,
    Orange = 0xFFA500,
    Yellow = 0xFFFF00,
    Green = 0x00FF00,
    Blue = 0x0000FF,
    Indigo = 0x4b0082,
    Violet = 0x8a2be2,
    Purple = 0xFF00FF,
    White = 0xFFFFFF,
    Black = 0x000000    
}

/* 
 * Class to store information about a fixture's channels.
 * In DMX512 you can have up to a total of 512 channels.
 */
export class Fixture {
    public numChannels : number;
    public channels : Array<Channel>;

    constructor(numberChannels : number) {
        this.channels = [];
        this.numChannels = numberChannels;
        let i = 0;
        while (i < this.numChannels) {
            let channel = new Channel();
            this.channels.push(channel);
            i++;
        }
    }

    updateChannel(channel: number, value: number): void {
        this.channels[channel-1].value = value;
     }  
}

export class RGBFixture extends Fixture {
    public brightnessChannel : number;
    public redChannel : number;
    public greenChannel : number;
    public blueChannel : number;

    constructor(numberChannels : number, lightType : string) {
        super(numberChannels);
        switch(lightType) {
            case "Baisun8ch":
                this.brightnessChannel = 1;
                this.redChannel = 2;
                this.greenChannel = 3;
                this.blueChannel = 4;
              break;
            default: // "Coidak8ch"
                this.brightnessChannel = 4;
                this.redChannel = 5;
                this.greenChannel = 6;
                this.blueChannel = 7;
          }
    }

    setBrightness(value: number): void { 
        this.channels[this.brightnessChannel-1].value = value;
    }        

    setColor(value: number): void {
        let rgbValues = hexToRgb(value);
        this.channels[this.redChannel-1].value = rgbValues['r'];
        this.channels[this.greenChannel-1].value = rgbValues['g'];
        this.channels[this.blueChannel-1].value = rgbValues['b'];

     }       
}

export class Channel {
    public value : number;

    constructor() {
        this.value = 0;
    }
}


/*
/* Method to create new DMX fixture
 * The order that the fixtures are declared needs to match the way
 * the rig is physically wired. This will change once we add support
 * for the layout editor extension
 */
export function createFixture(numChannels: number) : Fixture {
    console.info("Creating dmx fixture");
    let fixture = new Fixture(numChannels)
    allFixtures.push(fixture);
    return fixture;
}

/* Method to create new Prefab DMX fixture
 * The order that the fixtures are declared needs to match the way
 * the rig is physically wired. This will change once we add support
 * for the layout editor extension
 */
export function createRGBFixture(fixtureType: RGBFixtureType) : RGBFixture {
    let fixtureTypeName : string = "";
    switch (fixtureType) {
        case RGBFixtureType.Baisun8ch:
            fixtureTypeName = "Baisun8ch";
            break;
        case RGBFixtureType.Coidak8ch:
            fixtureTypeName = "Coidak8ch";
            break;
        default:
            fixtureTypeName = "";
    }
    let rgbFixture = new RGBFixture(8, fixtureTypeName);
    allFixtures.push(rgbFixture);
    return rgbFixture;
}

/* Send the updated channel information to the DMX controller */
export function send() : void {
    console.info("Sending updated dmx info to controller");
    dmxController.update(universeName, generateDMXJson());
}

/* runtime implementation of autogenerated test block from dmx editor extension */
export function test(num: number) {
    console.info(num);
}

export function generateDMXJson() : any {
    let dmxChannels : any = {};
    let channelCount = 1;
    for (let i = 0; i < allFixtures.length; i++) {
        let fixture = allFixtures[i];
        for (let j = 0; j < fixture.numChannels; j++) {
            let index : number = channelCount + j;
            dmxChannels[index as number] = fixture.channels[j].value;
        }
        channelCount += fixture.numChannels;
    }
    console.info(dmxChannels);
    return dmxChannels;
}

export function colors(color: Colors): number {
    return color;
}

export function rgb(red: number, green: number, blue: number): number {
    return ((red & 0xFF) << 16) | ((green & 0xFF) << 8) | (blue & 0xFF); // returns a hex number
}

export function hexToRgb(value: number) {
    let r = (value >> 16) & 255;
    let g = (value >> 8) & 255;
    let b = value & 255;
    return {r: r, g: g, b: b};
}

/* Eventually the rig editor will generate blocks like
 * "show scene", "play pattern", "loop pattern", "stop pattern"
 * scenes -> patterns -> shows (the user can do all 3 in makecode or
 * just do the actual triggering mechanisms therefore creating a show)
 */